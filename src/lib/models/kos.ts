import { supabase, supabaseAdmin } from '@/lib/supabase';
import { 
  KosListing, 
  KosListingWithDetails, 
  KosMarker, 
  KosFilters,
  CreateKosRequest,
  UpdateKosRequest 
} from '@/types/database';

export class KosModel {
  // Get all kos for map view with optional filters
  static async getKosMarkers(filters?: KosFilters): Promise<KosMarker[]> {
    let query = supabase
      .from('kos_listings')
      .select(`
        id, title, slug, gender, monthly_price, 
        latitude, longitude, distance_to_its_km, available_rooms
      `);

    // Apply filters
    if (filters?.gender) {
      query = query.eq('gender', filters.gender);
    }
    
    if (filters?.min_price) {
      query = query.gte('monthly_price', filters.min_price);
    }
    
    if (filters?.max_price) {
      query = query.lte('monthly_price', filters.max_price);
    }
    
    if (filters?.max_distance) {
      query = query.lte('distance_to_its_km', filters.max_distance);
    }
    
    if (filters?.available_only) {
      query = query.gt('available_rooms', 0);
    }

    const { data, error } = await query.order('distance_to_its_km', { ascending: true });
    
    if (error) throw error;
    return data || [];
  }

  // Get single kos with full details
  static async getKosDetails(slug: string): Promise<KosListingWithDetails | null> {
    const { data, error } = await supabase
      .from('kos_listings')
      .select(`
        *,
        users!kos_listings_owner_id_fkey(id, name, email),
        kos_facilities(
          facility_id, is_available, extra_price,
          facility_types(id, name, icon)
        ),
        reviews(
          id, rating, comment, created_at,
          users!reviews_user_id_fkey(name)
        )
      `)
      .eq('slug', slug)
      .single();

    if (error) {
      if (error.code === 'PGRST116') return null; // Not found
      throw error;
    }

    // Calculate average rating
    const ratings = data.reviews?.map((r: any) => r.rating) || [];
    const average_rating = ratings.length > 0 
      ? ratings.reduce((sum: number, rating: number) => sum + rating, 0) / ratings.length 
      : 0;

    return {
      ...data,
      owner: data.users,
      facilities: data.kos_facilities?.map((kf: any) => ({
        ...kf.facility_types,
        extra_price: kf.extra_price,
        is_available: kf.is_available
      })) || [],
      average_rating,
      total_reviews: ratings.length
    };
  }

  // Get kos owned by specific user
  static async getKosByOwner(ownerId: string): Promise<KosListing[]> {
    const { data, error } = await supabase
      .from('kos_listings')
      .select('*')
      .eq('owner_id', ownerId)
      .order('created_at', { ascending: false });

    if (error) throw error;
    return data || [];
  }

  // Create new kos listing
  static async createKos(kosData: CreateKosRequest, ownerId: string): Promise<KosListing> {
    const client = supabaseAdmin || supabase;
    
    const { data, error } = await client
      .from('kos_listings')
      .insert({
        ...kosData,
        owner_id: ownerId,
        slug: '' // Will be auto-generated by trigger
      })
      .select()
      .single();

    if (error) throw error;

    // Add facilities if provided
    if (kosData.facilities && kosData.facilities.length > 0) {
      const facilitiesData = kosData.facilities.map(f => ({
        kos_id: data.id,
        facility_id: f.facility_id,
        extra_price: f.extra_price || 0
      }));

      const { error: facilityError } = await client
        .from('kos_facilities')
        .insert(facilitiesData);

      if (facilityError) throw facilityError;
    }

    return data;
  }

  // Update kos listing
  static async updateKos(kosData: UpdateKosRequest, ownerId: string, userRole: string): Promise<KosListing> {
    const client = supabaseAdmin || supabase;
    
    // Check ownership or admin access
    if (userRole !== 'ADMIN') {
      const { data: existingKos } = await client
        .from('kos_listings')
        .select('owner_id')
        .eq('id', kosData.id)
        .single();

      if (!existingKos || existingKos.owner_id !== ownerId) {
        throw new Error('Unauthorized: You can only edit your own kos listings');
      }
    }

    const { id, facilities, ...updateData } = kosData;
    
    const { data, error } = await client
      .from('kos_listings')
      .update(updateData)
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;

    // Update facilities if provided
    if (facilities) {
      // Delete existing facilities
      await client.from('kos_facilities').delete().eq('kos_id', id);
      
      // Insert new facilities
      if (facilities.length > 0) {
        const facilitiesData = facilities.map(f => ({
          kos_id: id,
          facility_id: f.facility_id,
          extra_price: f.extra_price || 0
        }));

        const { error: facilityError } = await client
          .from('kos_facilities')
          .insert(facilitiesData);

        if (facilityError) throw facilityError;
      }
    }

    return data;
  }

  // Delete kos listing
  static async deleteKos(kosId: number, ownerId: string, userRole: string): Promise<void> {
    const client = supabaseAdmin || supabase;
    
    // Check ownership or admin access
    if (userRole !== 'ADMIN') {
      const { data: existingKos } = await client
        .from('kos_listings')
        .select('owner_id')
        .eq('id', kosId)
        .single();

      if (!existingKos || existingKos.owner_id !== ownerId) {
        throw new Error('Unauthorized: You can only delete your own kos listings');
      }
    }

    const { error } = await client
      .from('kos_listings')
      .delete()
      .eq('id', kosId);

    if (error) throw error;
  }

  // Get all kos (admin only)
  static async getAllKos(): Promise<KosListingWithDetails[]> {
    const client = supabaseAdmin || supabase;
    
    const { data, error } = await client
      .from('kos_listings')
      .select(`
        *,
        users!kos_listings_owner_id_fkey(name, email)
      `)
      .order('created_at', { ascending: false });

    if (error) throw error;
    
    return (data || []).map(kos => ({
      ...kos,
      owner: kos.users
    }));
  }

  // Get user's own kos listings
  static async getUserKosListings(ownerId: string): Promise<KosListing[]> {
    const { data, error } = await supabase
      .from('kos_listings')
      .select('*')
      .eq('owner_id', ownerId)
      .order('created_at', { ascending: false });

    if (error) throw error;
    return data || [];
  }

  // Get all kos listings for admin with owner information
  static async getAllKosForAdmin() {
    const client = supabaseAdmin || supabase;
    
    const { data, error } = await client
      .from('kos_listings')
      .select(`
        id,
        title,
        slug,
        gender,
        monthly_price,
        available_rooms,
        total_rooms,
        address,
        created_at,
        owner:users!kos_listings_owner_id_fkey (
          id,
          name,
          email
        )
      `)
      .order('created_at', { ascending: false });

    if (error) throw error;
    return data;
  }
}